<p>
    The Database Service allows you to store your application and users’ data and fetch it using different supported queries.
    Using your Appwrite Database, you can organize your data into collections and documents using your database of choice.
    In addition, the Database Service provides built-in validation to check the integrity of your incoming data, custom indexing for query performance, 
    as well as a flexible permission mechanism to allow you to segment data between different users, teams, and roles.
</p>

<h2>Create Your Collections</h2>
<p>
    Appwrite uses collections as containers of documents.
    The term collection is used because the Appwrite JSON REST API resembles the API of a traditional NoSQL database, but internally when using an SQL adapter like MariaDB or MySQL, Appwrite will store your documents on native SQL tables.
</p>

<p>
    You can create your collection by adding it from your Appwrite project’s dashboard. Access your Database settings from your project’s left navigation panel.
    Click the ‘Add Collection’ button and choose your collection’s name. For convenience, you can also set a custom ID for your collection instead of an auto-generated ID.
</p>

<div class="notice margin-top-large margin-bottom-large">
    <p>To work with collections in code, check out our Server SDKs. Any one of our Server and Client SDKs can be used to work with documents.</p>
</div>

<h3>Document or Collection Level Permissions</h3>
<p>
    Once you create your collection, the dashboard will navigate to the collection’s settings so you can choose the permission model for your collection. Check out the Permissions documentation to learn more about the possible permission types.
</p>

<h4>Document Level Permissions</h4>
<p>
    With this permission model, you have granular access control over every document, and users will only be able to access documents for which they have explicit permissions. Document permissions are required in this permission model, and collection permissions are optional.
</p>

<h4>Collection Level Permissions</h4>
<p>
    With collection-level permissions, you assign permissions once for every document in the collection - users with read access to the collection can see all documents. Collection permissions are required in this permission model, and document permissions are optional.
</p>

<div class="notice margin-top-large margin-bottom-large">
    <p>Note: For security purposes, an active Account session is required to create resources. So, even if wildcard write permissions are set, only logged-in users can create documents in a collection. If you require this behavior for your app, create an anonymous session first.</p>
</div>


<h2>Create Attributes</h2>
<p>
    Once you choose your permission model, navigate to the <b>Attributes</b> tab of your collection. Attributes are used to define the structure of your documents, so add your first by clicking the <b>Add Attribute</b> button. You can choose from the following types:
</p>
<table cellspacing="0" cellpadding="0" border="0" class="full margin-bottom-large">
    <thead>
        <tr>
            <th style="width: 250px">Attribute</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>string</td>
            <td>String attribute.</td>
        </tr>
        <tr>
            <td>integer</td>
            <td>Integer attribute.</td>
        </tr>
        <tr>
            <td>float</td>
            <td>Float attribute.</td>
        </tr>
        <tr>
            <td>boolean</td>
            <td>Boolean attribute.</td>
        </tr>
        <tr>
            <td>enum</td>
            <td>Enum attribute.</td>
        </tr>
        <tr>
            <td>ip</td>
            <td>IP address attribute for IPv4 and IPv6.</td>
        </tr>
        <tr>
            <td>email</td>
            <td>Email address attribute.</td>
        </tr>
        <tr>
            <td>url</td>
            <td>URL attribute.</td>
        </tr>
    </tbody>
</table>

<p>
    If an attribute must be present in all documents, set it as <span class="tag">required</span>. If not, a <span class="tag">default</span> value might be handy. Additionally, decide if the attribute should be a primitive or array of values.
</p>
<p>
    When adding or removing attributes, your requests are processed in the background, indicated by the attribute’s <span class="tag">status</span>. Depending on your collection’s size and other factors, this could take anywhere from a few seconds to a few minutes to complete. Once all of your attributes are <span class="tag">available</span>, then you can create a document.
</p>

<h3>Create Documents</h3>
<p>
    Navigate to the <b>Documents</b> tab of your collection and click the <b>Add Document</b> button, or add a document from code:
</p>
<div class="ide" data-lang="javascript" data-lang-label="Web SDK">
    <pre class="line-numbers"><code class="prism language-javascript" data-prism>import { Appwrite } from "appwrite";

const sdk = new Appwrite();
const promise = sdk.database.createDocument('[COLLECTION_ID]', {});

promise.then(function (response) {
    console.log(response); // Success
}, function (error) {
    console.log(error); // Failure
});
</code></pre>
</div>

<h3>Finding Documents</h3>
<p>
    To find specific documents in a collection, pass an array of query strings as a parameter to the <a href="/docs/server/database#databaseListDocuments">listDocuments</a> endpoint. The SDKs provide a <span class="tag">Query</span> class to make query building simpler:
</p>
<div class="ide" data-lang="javascript" data-lang-label="Web SDK">
    <pre class="line-numbers"><code class="prism language-javascript" data-prism>import { Query } from "appwrite";

sdk.database.listDocuments('movies', [
    Query.equal('title', 'Avatar')
]);
</code></pre>
</div>

<p>The following operators are currently supported:</p>
<table cellspacing="0" cellpadding="0" border="0" class="full margin-bottom-large">
    <thead>
        <tr>
            <th style="width: 250px">Operator</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>equal</td>
            <td></td>
        </tr>
        <tr>
            <td>notEqual</td>
            <td></td>
        </tr>
        <tr>
            <td>lesserEqual</td>
            <td></td>
        </tr>
        <tr>
            <td>greater</td>
            <td></td>
        </tr>
        <tr>
            <td>greaterEqual</td>
            <td></td>
        </tr>
        <tr>
            <td>search</td>
            <td>requires a Fulltext Index</td>
        </tr>
    </tbody>
</table>

<p>Each query string is logically separated via AND. For OR logic, pass multiple values, separated by commas:</p>
<div class="ide" data-lang="javascript" data-lang-label="Web SDK">
    <pre class="line-numbers"><code class="prism language-javascript" data-prism>
sdk.database.listDocuments('movies', [
    Query.equal('title', 'Avatar', 'Lord of the Rings'),
    Query.greater('year', 1999)
]);
</code></pre>
</div>

<h2>Indexes</h2>
<p>
    Indexes are used by databases to quickly locate data without having to search through every document for results. 
    To ensure the best performance, Appwrite requires an index for every query. 
    You can create an index by navigating to the <b>Indexes</b> tab of your collection, or by using your favorite Server SDK.
</p>
<p>
    The following indexes are currently supported:
</p>
<table cellspacing="0" cellpadding="0" border="0" class="full margin-bottom-large">
    <thead>
        <tr>
            <th style="width: 250px">Type</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Key</td>
            <td>Plain Index</td>
        </tr>
        <tr>
            <td>Unique</td>
            <td></td>
        </tr>
        <tr>
            <td>Fulltext</td>
            <td>for searching within string attributes</td>
        </tr>
    </tbody>
</table>

<h2>Known Limitations</h2>

<h2>Benchmarks</h2>