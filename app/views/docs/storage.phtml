<p>Appwrite storage allow you to manage files in your project. It provides APIs to upload, download, delete, and list files. Not only that Appwrite storage service provides APIs to manipulate images. Using the preview endpoint you can crop, resize, rotate, add borders and border radius and select the desired output format for your image.</p>

<p>Appwrite storage service is a simple and easy to use service. You can use it to store images, videos, documents, and other files for your projects.</p>

<p>With version 0.13 of Appwrite, we also have introduced storage buckets as a container for your files so that you can give more context to your files. Storage buckets is similar to Collections we have in our <a href="/docs/database">Database</a> service. The difference is, buckets gives you more control over what types of <b>files</b> you allow, what is the maximum allowed file size, and whether or not to encrypt the files.</p>

<h2><a href="/docs/storage#bucket" id="bucket">Buckets</a></h2>

<p> Storage buckets are a way to group files into a meaningful collection and give them context. Buckets also provide more power to decide what kinds of files, what sizes you want to allow in that bucket, whether or not to encrypt the files, scan with antivirus and more. Let's look at how we can create a bucket and configure it to your needs.</p>

<h3><a href="/docs/storage#createBucket" id="createBucket">Create Bucket</a></h3>

<p>You can create your bucket from your Appwrite project's dashboard, using any of our server side SDKs, or directly using our REST API authenticated using an API Key. In order to create a bucket from the dashboard, access your Storage from your project's left navigation panel. Click <b>Add Bucket</b> button and choose your bucket's name. For convenience, you can also set a custom ID for your bucket instead of auto-generated ID. This will create a new bucket and take you to its settings page, where you can configure various options for your bucket.</p>

<p>You can manage your buckets programmatically using one of Appwrite's Server <a href="/docs/sdks#server">SDKs</a> or REST API paired with an API Key. You can manage files with both Server and Client side.</p>

<h4><a href="/docs/storage#permission" id="permission">Permissions</a></h4>

As buckets are very similar to Collections we have in the database, here again, we have a similar permission model. Buckets support either bucket level permission or file level permission to allow different ways to manage access to your buckets and files. Check out the <a href="/docs/permissions">Permissions</a> documentation to learn more about permissions types available.

<h4>Bucket Level Permissions</h4>

<p>With bucket level permissions, you only need to provide permissions in your bucket and not in files. If you set the permissions at the bucket level, file permissions are optional and ignored even if you have set them. This is useful when you want to provide the same permission for collections of files but don't want to repeat the same permission for each file. You provide it once for bucket, set the bucket permissions to be bucket level and you are done. If you want to update the permission, you only need to do it once in the bucket. With this permission model, if a user has a read and write permission, they will be able to read all the files and modify all the files in that bucket.</p>

<p>However, with this permission model, you don't have granular control over the files inside the bucket. This model is more suitable for a use case where you have many people who all have access to the same group of files. Instead of adding their permission to each file, you can just create a bucket with bucket level permission and provide them access. Now you can add all the files they should have access to inside that bucket.</p>

<h4>File Level Permission</h4>

<p>With file level permission model, you have more granular control over the access of each file. With this permission model, the bucket permissions are ignored and permissions on each file take into effect whenever we are trying to read or write files into the bucket. This is more suitable in the use cases where you want to have different permission for each file. For example, you have a bucket for user's profile images, and you only want each user to only be able to modify their own image. In such a scenario, a file level permission model will make much more sense and will be easier to manage.</p>

<div class="notice margin-top-large margin-bottom-large">
    <h5>Active Session Required</h5>

    <p>For security purposes, an active Account session is required to create resources. So, even if wildcard write permissions are set, only logged-in users can create files in a bucket. If you require this behavior for your app, create an <a href="/docs/client/account?sdk=web-default#accountCreateAnonymousSession" target="_blank">anonymous session</a> first. An active session helps Appwrite enforce rate-control limits and protect your projects from intensive write operations.</p>
</div>

<h4><a href="/docs/storage#bucketConfig" id="bucketConfig">More Bucket Configurations</a></h4>

<p>Unlike Collections, storage buckets have more configuration options regarding the type and size of files that can be in the bucket, encryption and anti-virus scanning. If you look at the bucket settings or the REST API example above you can find these configurations. Let's look at what those are:</p>

<table>
    <thead>
        <tr>
            <th>Parameter</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>allowedFileExtensions</td>
            <td>parameter allows you to provide a list of file extensions that will be accepted into the bucket.</td>
        </tr>
        <tr>
            <td>maximumFileSize</td>
            <td> parameter allows you to set the maximum size of a file that a bucket accepts. The buckets will accept any file less than or equal to the size provided here.</td>
        </tr>
        <tr>
            <td>encryption</td>
            <td> parameter allows you to configure whether or not the files inside the bucket will be encrypted.</td>
        </tr>
        <tr>
            <td>antivirus</td>
            <td> parameter allows you to configure whether or not the files being added inside the bucket be scanned by antivirus.</td>
        </tr>
    </tbody>
</table>

<p>You can learn more about storage buckets and APIs you can use to manage storage buckets from our <a href="docs/server/storage">Storage documentation</a>. Now that we know how to create and configure buckets for our applications, let's look at how we can manage files using the storage service.</p>

<h2><a href="/docs/storage#createFile" id="createFile">Create File</a></h2>

<p>After you create a bucket or have navigated to bucket details, you can access the Files tab so you can upload, view, delete and update files in the bucket using Appwrite project's dashboard. You can also perform all those operations from Appwrite's client SDK, server SDKs, and REST APIs as long as you have proper permission.</p>

<p>When you are in the files tab, you can click <b>Add File</b> and select a file to upload. If the bucket is configured to accept the file type and size you are uploading, your file will be uploaded and you will see the file in the list of files.</p>

<p>You can also upload file programmatically using our SDKs</p>

<ul class="phases clear" data-ui-phases>
    <li>
        <h3>Web</h3>
        <div class="ide" data-lang="javascript" data-lang-label="Web SDK">
            <pre class="line-numbers"><code class="prism language-javascript" data-prism>import { Appwrite } from "appwrite";

const sdk = new Appwrite();
const promise = sdk.storage.createFile('[BUCKET_ID]', 'unique()', document.getElementById('uploader').files[0]);

promise.then(function (response) {
    console.log(response); // Success
}, function (error) {
    console.log(error); // Failure
});
            </code></pre>
        </div>
    </li>
    <li>
        <h3>Flutter</h3>
        <div class="ide" data-lang="dart" data-lang-label="Flutter SDK">
            <pre class="line-numbers"><code class="prism language-dart" data-prism>import 'package:appwrite/appwrite.dart';

void main() { // Init SDK
  Client client = Client();
  Storage storage = Storage(client);

  client
    .setEndpoint('https://[HOSTNAME_OR_IP]/v1') // Your API Endpoint
    .setProject('5df5acd0d48c2') // Your project ID
  ;
  Future result = storage.createFile(
    bucketId: '[BUCKET_ID]',
    fileId: '[FILE_ID]',
    file: await MultipartFile.fromPath('file', './path-to-files/image.jpg', 'image.jpg'),
  );

  result
    .then((response) {
      print(response);
    }).catchError((error) {
      print(error.response);
  });
}</code></pre>
        </div>
    </li>
    <li>
        <h3>Android</h3>
        <div class="ide" data-lang="android" data-lang-label="Android SDK">
            <pre class="line-numbers"><code class="prism language-android" data-prism>import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.launch
import io.appwrite.Client
import io.appwrite.services.Storage

class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        val client = Client(applicationContext)
            .setEndpoint("https://[HOSTNAME_OR_IP]/v1") // Your API Endpoint
            .setProject("5df5acd0d48c2") // Your project ID

        val storage = Storage(client)

        GlobalScope.launch {
            val response = storage.createFile(
                bucketId = "[BUCKET_ID]",
                fileId = "[FILE_ID]",
                file = File("./path-to-files/image.jpg"),
            )
            val json = response.body?.string()        
        }
    }
}</code></pre>
        </div>
    </li>
    <li>
        <h3>Apple</h3>
        <div class="ide" data-lang="swift" data-lang-label="Apple SDK">
            <pre class="line-numbers"><code class="prism language-swift" data-prism>import Appwrite

func main() {
    let client = Client()
      .setEndpoint("https://[HOSTNAME_OR_IP]/v1") // Your API Endpoint
      .setProject("5df5acd0d48c2") // Your project ID

    let storage = Storage(client)
    storage.createFile(
        bucketId: "[BUCKET_ID]",
        fileId: "[FILE_ID]",
        file: File(name: "image.jpg", buffer: yourByteBuffer)
    ) { result in
        switch result {
        case .failure(let error):
            print(error.message)
        case .success(let file):
            print(String(describing: file)
        }
    }
}</code></pre>
        </div>
    </li>
</ul>

<h3>Large Files (files above 5MB)</h3>

<p>If you are trying to upload any files that are above 5MB, you will need to upload them in chunks. Don't worry, if you are using Appwrite's console or any of our SDKs we handle that internally, so no matter what file size you try to upload, it will work.</p>
<p>If however you want to use REST API directly, below is a code example in Dart, that shows how you can upload a large file by chunking it into smaller ones. We are using the content-range header provided in the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Range">web spec</a> in order to support chunked upload. You need to provide chunks and those headers to make a successful upload.</p>

<div class="ide margin-bottom" data-lang="dart" data-lang-label="Upload Large File">
    <pre class="line-numbers"><code class="prism language-dart" data-prism>void uploadFile() async {
  final client = Client();
  client
    .setEndpoint('YOUR_ENDPOINT')
    .setProject('YOUR_PROJECT_ID');
  final file = File(path);
  final totalSize = file.lengthSync();
  final chunkSize = 5 * 1024 * 1024;
  var start = 0;
  final raf = file.openSync(mode: FileMode.read);
  var counter = 0;
  while (start < totalSize) {
    counter++;
    raf.setPositionSync(start);
    final contents = raf.readSync(chunkSize);
    final mfile = MultipartFile.fromBytes(contents, filename: 'hello.mkv');
    final contentRanges =
        'bytes $start-${min<int>(((start + chunkSize) - 1), totalSize)}/$totalSize';
    var headers = {
      'content-type': 'multipart/form-data',
      'content-range': contentRanges,
      'x-appwrite-project': 'YOUR_PROJECT_ID',
      'x-appwrite-key': 'YOUR_API_KEY'
    };
    try {
      final res = await client.call(HttpMethod.post,
          path: '/storage/buckets/BUCKET_ID/files',
          headers: headers,
          params: <String, dynamic>{
            'fileId': 'unique()',
            'file': mfile,
            'read': ['role:all'],
            'write': ['role:all']
          });
      start += chunkSize;
    } on AppwriteException catch (e) {
      print(e.message);
      print(e.response);
    }
  }
}</code></pre>
</div>

<h2><a href="/docs/storage#imagePreview" id="imagePreview">Image Manipulation</a></h2>

<p>Another great built-in feature of Appwrite is the image manipulation feature. With Appwrite storage's <a href="/docs/client/storage#storageGetFilePreview">preview endpoint</a> you can manipulate resolution, add borders and border radius, add background colour, set the opacity for the image and get the image in the appropriate output format. This enables a wide range of possibilities! You can manipulate images resolution to display properly on responsive websites. You can also adjust image border, background colour and border radius to match the theming of your application. You can do all of that without caring about how the image was originally uploaded.</p>

<p>Below you can find all different parameters offered by preview endpoint to manipulate image</p>

<table cellspacing="0" cellpadding="0" border="0" class="full margin-bottom-large">
    <thead>
        <tr>
            <th style="width: 250px">Parameter</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>height</td>
            <td>set the height of the output image in pixels, the image will be resized keeping the aspect ratio intact. Accepts integer between 0-4000</td>
        </tr>
        <tr>
            <td>width</td>
            <td> set the width of the output image in pixels, the image will be resized keeping the aspect ratio intact. Accepts integer between 0-4000</td>
        </tr>
        <tr>
            <td>gravity</td>
            <td> the gravity while cropping the image providing either width, height or both. Accepts any of: center, top-left, top, top-right, left, right, bottom-left, bottom, bottom-right</td>
        </tr>
        <tr>
            <td>quality</td>
            <td> set the quality of the output image. Accepts integer between 0-100, where 100 is the highest quality.</td>
        </tr>
        <tr>
            <td>borderWidth</td>
            <td> set a border with given width in pixels to the output image. Accepts integer between 0-100</td>
        </tr>
        <tr>
            <td>borderColor</td>
            <td> set a border color for the output image. Accepts any valid Hex color value without the leading #.</td>
        </tr>
        <tr>
            <td>borderRadius</td>
            <td> set a border radius in pixels. Accepts an integer between 0-4000.</td>
        </tr>
        <tr>
            <td>opacity</td>
            <td> set opacity for the output image. Accepts a float value between 0-1, where 0 makes it transparent. Only works with output format supporting alpha channel like png.</td>
        </tr>
        <tr>
            <td>rotation</td>
            <td> rotate the output image by a degree. Accepts an integer between -360 to 360.</td>
        </tr>
        <tr>
            <td>background</td>
            <td> set a background color. Accepts any valid Hex color value without the leading #. Only works with output format supporting alpha channel like png.</td>
        </tr>
        <tr>
            <td>output</td>
            <td> set the output image format. If not provided, will use the original image's format. Supported formats are: jpg, jpeg, png, gif and webp</td>
        </tr>
    </tbody>
</table>


<h2><a href="/docs/storage#streaming" id="streaming">Downloading and streaming with range</a></h2>

<p>Apart from previewing files and images, downloading is another important feature. With 0.13 we also support streamed download using the HTTP range header. If you are using our SDKs or console, nothing is different. Even if you want to download the whole file at once, even if you use the REST endpoint directly, there isn't any difference. However, if you want to get only a part of a file from storage, you can supply the range header and the server will respond with an appropriate chunk of the file.</p>